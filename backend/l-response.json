{
  "Lesson" : {
    "UUID" : "65967ee2-e5a8-4aa6-b5fe-dd12568c07a9",
    "Slug" : "6-salts",
    "Type" : "type_code_tests",
    "CourseUUID" : "6321ddbf-49eb-4748-9737-6bc12e8bb705",
    "CourseTitle" : "Learn Cryptography in Go",
    "CourseImageURL" : "",
    "CourseSlug" : "learn-cryptography-golang",
    "ChapterUUID" : "80b772b7-f7e4-49b5-b705-708b36404fb5",
    "ChapterTitle" : "KDFs",
    "ChapterSlug" : "14-kdf",
    "IsFree" : false,
    "LastMod" : "2024-11-13T00:38:38-05:00",
    "CompletionType" : "completion_type_standard",
    "Title" : "Salts",
    "LessonDataCodeCompletion" : null,
    "LessonDataCodeCompletionSQL" : null,
    "LessonDataMultipleChoice" : null,
    "LessonDataHTTPTests" : null,
    "LessonDataGitHubChecks" : null,
    "LessonDataManual" : null,
    "LessonDataCodeTests" : {
      "Readme" : "# Salts\n\n## Rainbow Tables\n\n[Rainbow tables](https://en.wikipedia.org/wiki/Rainbow_table#:~:text=A%20rainbow%20table%20is%20a,a%20limited%20set%20of%20characters.) are a way for attackers to get around slow KDFs. Attackers can pre-hash all of the common passwords once, then compare this list (called a \"rainbow table\") to the list of hashes in a compromised database and see if any match.\n\nIf the hashes match, then the attacker will know the original password, which they might then be able to use to log in to the user's bank account (or any other place they use the same password).\n\n## Salts to the rescue\n\nA [salt](https://en.wikipedia.org/wiki/Salt_(cryptography)) is a random chunk of data added to a password before it is hashed so that its output hash will differ from the hash of the same password with a different salt.\n\nFor example:\n\n```go\ndigest := hash(password+salt)\n// save the digest AND salt\n// checking the hash now involves the salt, hash, and the password to check\n```\n\nA rainbow table is ineffective against a salted database, as long as the salt generated for each password is unique.\n\n## Assignment\n\nWe have an existing database of users and their passwords. We're working with a third-party vendor, and unfortunately, they didn't salt their passwords *and* they're using SHA-256 instead of a slow KDF. We can only tackle one problem at a time, so for now, we've just been asked to salt and re-hash the passwords. We can migrate from SHA-256 to Bcrypt later.\n\nTo do that, we need all of our users to reset their passwords, because we don't store the plaintext.\n\nComplete the `generateSalt` and `hashPassword` functions.\n\n### generateSalt\n\nUse `crypto/rand` to generate a random salt of the specified length. Use [rand.Read()](https://pkg.go.dev/crypto/rand#Read).\n\n### hashPassword\n\nAppend the salt directly to the *end* of the password, then hash it with SHA-256. Use [crypto/sha256](https://pkg.go.dev/crypto/sha256#Sum256). Return the result of the hash.\n",
      "ProgLang" : "go",
      "StarterFiles" : [ {
        "Name" : "main.go",
        "Content" : "package main\n\nfunc generateSalt(length int) ([]byte, error) {\n\t// ?\n}\n\nfunc hashPassword(password, salt []byte) []byte {\n\t// ?\n}\n",
        "IsHidden" : false,
        "IsReadonly" : false
      }, {
        "Name" : "main_js_test.go",
        "Content" : "//go:build js && wasm\n\npackage main\n\nimport \"syscall/js\"\n\nfunc init() {\n\tif !js.Global().Get(\"withSubmit\").Bool() {\n\t\twithSubmit = false\n\t}\n}\n",
        "IsHidden" : true,
        "IsReadonly" : false
      }, {
        "Name" : "main_test.go",
        "Content" : "package main\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestPasswordHashing(t *testing.T) {\n\ttype testCase struct {\n\t\tpassword1 string\n\t\tpassword2 string\n\t\tsaltLen   int\n\t\texpect    bool\n\t}\n\n\ttests := []testCase{\n\t\t{\"samepass\", \"samepass\", 16, true},\n\t\t{\"passone\", \"passtwo\", 24, false},\n\t\t{\"correct horse battery staple\", \"correct horse battery staple\", 32, true},\n\t}\n\n\tif withSubmit {\n\t\ttests = append(tests, []testCase{\n\t\t\t{\"bigtimepass\", \"notthesame\", 16, false},\n\t\t\t{\"kaladin\", \"kaladin\", 24, true},\n\t\t\t{\"stormlight archive\", \"stormlight archive\", 32, true},\n\t\t}...)\n\t}\n\n\tfor _, test := range tests {\n\t\tsalt, err := generateSalt(test.saltLen)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Error generating salt: %v\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\thashed1 := hashPassword([]byte(test.password1), salt)\n\t\thashed2 := hashPassword([]byte(test.password2), salt)\n\n\t\tmatch := string(hashed1) == string(hashed2)\n\t\tif match != test.expect {\n\t\t\tt.Errorf(`---------------------------------\nPassword 1:  %s\nPassword 2:  %s\nSalt length: %d\nExpecting:   %v\nActual:      %v\nFail`, test.password1, test.password2, test.saltLen, test.expect, match)\n\t\t} else {\n\t\t\tfmt.Printf(`---------------------------------\nPassword 1:  %s\nPassword 2:  %s\nSalt length: %d\nExpecting:   %v\nActual:      %v\nPass\n`, test.password1, test.password2, test.saltLen, test.expect, match)\n\t\t}\n\t}\n}\n\nvar withSubmit = true\n",
        "IsHidden" : false,
        "IsReadonly" : true
      } ],
      "SolutionFiles" : [ {
        "Name" : "main.go",
        "Content" : "package main\n\nimport (\n\t\"crypto/rand\"\n\t\"crypto/sha256\"\n)\n\nfunc generateSalt(length int) ([]byte, error) {\n\tsalt := make([]byte, length)\n\t_, err := rand.Read(salt)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn salt, nil\n}\n\nfunc hashPassword(password, salt []byte) []byte {\n\tpassword = append(password, salt...)\n\thashed := sha256.Sum256(password)\n\treturn hashed[:]\n}\n",
        "IsHidden" : false,
        "IsReadonly" : false
      }, {
        "Name" : "main_js_test.go",
        "Content" : "//go:build js && wasm\n\npackage main\n\nimport \"syscall/js\"\n\nfunc init() {\n\tif !js.Global().Get(\"withSubmit\").Bool() {\n\t\twithSubmit = false\n\t}\n}\n",
        "IsHidden" : true,
        "IsReadonly" : false
      }, {
        "Name" : "main_test.go",
        "Content" : "package main\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestPasswordHashing(t *testing.T) {\n\ttype testCase struct {\n\t\tpassword1 string\n\t\tpassword2 string\n\t\tsaltLen   int\n\t\texpect    bool\n\t}\n\n\ttests := []testCase{\n\t\t{\"samepass\", \"samepass\", 16, true},\n\t\t{\"passone\", \"passtwo\", 24, false},\n\t\t{\"correct horse battery staple\", \"correct horse battery staple\", 32, true},\n\t}\n\n\tif withSubmit {\n\t\ttests = append(tests, []testCase{\n\t\t\t{\"bigtimepass\", \"notthesame\", 16, false},\n\t\t\t{\"kaladin\", \"kaladin\", 24, true},\n\t\t\t{\"stormlight archive\", \"stormlight archive\", 32, true},\n\t\t}...)\n\t}\n\n\tfor _, test := range tests {\n\t\tsalt, err := generateSalt(test.saltLen)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Error generating salt: %v\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\thashed1 := hashPassword([]byte(test.password1), salt)\n\t\thashed2 := hashPassword([]byte(test.password2), salt)\n\n\t\tmatch := string(hashed1) == string(hashed2)\n\t\tif match != test.expect {\n\t\t\tt.Errorf(`---------------------------------\nPassword 1:  %s\nPassword 2:  %s\nSalt length: %d\nExpecting:   %v\nActual:      %v\nFail`, test.password1, test.password2, test.saltLen, test.expect, match)\n\t\t} else {\n\t\t\tfmt.Printf(`---------------------------------\nPassword 1:  %s\nPassword 2:  %s\nSalt length: %d\nExpecting:   %v\nActual:      %v\nPass\n`, test.password1, test.password2, test.saltLen, test.expect, match)\n\t\t}\n\t}\n}\n\nvar withSubmit = true\n",
        "IsHidden" : false,
        "IsReadonly" : true
      } ]
    },
    "LessonDataTextInput" : null,
    "LessonDataCLICommand" : null
  },
  "LessonDifficulty" : 6
}